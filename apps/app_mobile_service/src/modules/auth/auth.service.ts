import { Injectable, NotFoundException, ConflictException, BadRequestException, Logger, Inject, forwardRef } from '@nestjs/common'; // Added forwardRef, Inject
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, DataSource, EntityManager } from 'typeorm'; // Added EntityManager
import { User, UserRole } from '../auth/entities/user.entity';
import { CreateUserDto } from '../auth/dto/create-user.dto'; // Assuming this can be used for the admin user
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { Company } from '../company/entities/company.entity'; // Corrected path
import { RefreshTokenDto } from './dto/refresh-token.dto';
import { EventsService } from '../events/events.service'; // Import EventsService
import { UserCreatedEventData, UserEventTopics, EventUserType } from '@wanzo/shared/events/kafka-config'; // Import event data interface and topics

export interface AuthResponse {
  user: Omit<User, 'password' | 'hashPassword' | 'validatePassword'>;
  token: string;
  refreshToken?: string; // Optional: if you implement refresh tokens
}

@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name); // Initialize logger

  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    @InjectRepository(Company) 
    private readonly companyRepository: Repository<Company>,
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
    private readonly dataSource: DataSource,
    @Inject(forwardRef(() => EventsService)) private readonly eventsService: EventsService, // Use forwardRef for EventsService
  ) {}

  async register(registerDto: RegisterDto): Promise<AuthResponse> {
    return this.dataSource.transaction(async (transactionalEntityManager: EntityManager) => { 
      // Check if admin email already exists
      const existingUser = await transactionalEntityManager.findOne(User, { where: { email: registerDto.adminEmail } });
      if (existingUser) {
        throw new ConflictException('User with this email already exists.');
      }

      // Check if company name already exists (optional, based on business rules)
      const existingCompany = await transactionalEntityManager.findOne(Company, { where: { name: registerDto.companyName } });
      if (existingCompany) {
        throw new ConflictException('Company with this name already exists.');
      }

      // Create and save the company
      const newCompany = transactionalEntityManager.create(Company, {
        name: registerDto.companyName,
        // TODO: Consider adding a unique ID generation here if not auto-generated by DB
        // or expect it from a central ID service if that's part of the architecture.
        // For now, relying on DB auto-generation for company.id
      });
      const savedCompany: Company = await transactionalEntityManager.save(Company, newCompany);

      // Create and save the admin user
      const adminUser = transactionalEntityManager.create(User, {
        email: registerDto.adminEmail,
        password: registerDto.adminPassword, // Password will be hashed by the entity's BeforeInsert/BeforeUpdate hook
        firstName: registerDto.adminName, // Assuming adminName is firstName, or split it
        phoneNumber: registerDto.adminPhone,
        role: UserRole.ADMIN, // Assign ADMIN role
        isActive: true,
        company: savedCompany,
        companyId: savedCompany.id,
      });
      
      await adminUser.hashPassword(); // Manually hash password before saving
      const savedAdminUser = await transactionalEntityManager.save(User, adminUser);

      // After successful user and company creation, publish UserCreatedEvent
      try {
        const userCreatedEvent: UserCreatedEventData = {
          userId: savedAdminUser.id,
          email: savedAdminUser.email,
          timestamp: new Date(),
          isOwner: true, // This user is the owner of the newly created company
          organizationDetails: {
            id: savedCompany.id, // Use the company ID as the organization ID
            name: savedCompany.name,
            // country: savedCompany.country, // If available and needed by accounting
            // industry: savedCompany.industry, // If available and needed by accounting
          },
          userType: EventUserType.SME_OWNER, // Explicitly set user type
          // Add other relevant fields from User entity if needed by consumers
          firstName: savedAdminUser.firstName,
          lastName: savedAdminUser.lastName, // Assuming lastName might exist or be added
          phoneNumber: savedAdminUser.phoneNumber,
          // companyId: savedCompany.id, // Already part of organizationDetails.id
        };
        await this.eventsService.publishUserCreated(userCreatedEvent);
        this.logger.log(`Published ${UserEventTopics.USER_CREATED} for user ${savedAdminUser.id} and company ${savedCompany.id}`);
      } catch (eventError) {
        // Log the error but don't let it fail the registration process
        // Critical event publishing failures might need a more robust retry/dead-letter queue strategy
        const eventErrorMessage = eventError instanceof Error ? eventError.message : 'Unknown event publishing error';
        this.logger.error(`Failed to publish ${UserEventTopics.USER_CREATED} event for user ${savedAdminUser.id}: ${eventErrorMessage}`, eventError instanceof Error ? eventError.stack : undefined);
      }

      const { password, ...userResult } = savedAdminUser;
      const token = await this._createToken(userResult);
      const refreshToken = await this._createRefreshToken(userResult.id);

      return {
        user: userResult,
        token,
        refreshToken,
      };
    });
  }

  async login(loginDto: LoginDto): Promise<AuthResponse> {
    const user = await this.userRepository.findOne({ 
        where: { email: loginDto.email },
        relations: ['company'] // Load company relation
    });

    if (!user || !(await user.validatePassword(loginDto.password)) || !user.isActive) {
      throw new NotFoundException('Invalid credentials or user inactive.');
    }

    user.lastLoginAt = new Date();
    await this.userRepository.save(user);

    const { password, ...userResult } = user;
    const token = await this._createToken(userResult);
    const refreshToken = await this._createRefreshToken(userResult.id);

    return {
      user: userResult,
      token,
      refreshToken,
    };
  }

  async refreshToken(refreshTokenDto: RefreshTokenDto): Promise<{ accessToken: string }> {
    try {
      const payload = await this.jwtService.verifyAsync(refreshTokenDto.refreshToken, {
        secret: this.configService.get<string>('JWT_REFRESH_SECRET'),
      });

      const user = await this.userRepository.findOne({ 
          where: { id: payload.sub },
          relations: ['company']
      });
      if (!user || !user.isActive) {
        throw new NotFoundException('User not found or inactive');
      }
      
      const { password, ...userResult } = user;
      const newAccessToken = await this._createToken(userResult);
      return { accessToken: newAccessToken };

    } catch (e) {
      // console.error('Refresh token error:', e); // Optional: for server-side logging
      throw new BadRequestException('Invalid refresh token');
    }
  }

  async validateUserById(userId: string): Promise<User | null> { // Changed return type to User | null
    const user = await this.userRepository.findOne({ 
        where: { id: userId, isActive: true },
        relations: ['company']
    });
    // No longer omitting password here; the strategy receives the full user object.
    // Sensitive data should be stripped before sending responses to the client.
    return user; 
  }

  async validateUserByPassword(loginDto: LoginDto): Promise<User | null> {
    const user = await this.userRepository.findOne({
      where: { email: loginDto.email },
      relations: ['company'],
    });

    if (user && (await user.validatePassword(loginDto.password)) && user.isActive) {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const { password, ...result } = user; // Exclude password from the returned user object
      return result as User; // Cast to User after omitting password
    }
    return null;
  }

  private async _createToken(user: Omit<User, 'password' | 'hashPassword' | 'validatePassword'>): Promise<string> {
    const payload = {
      sub: user.id,
      email: user.email,
      role: user.role,
      companyId: user.companyId,
    };
    return this.jwtService.signAsync(payload, {
      secret: this.configService.get<string>('JWT_ACCESS_SECRET'),
      expiresIn: this.configService.get<string>('JWT_ACCESS_EXPIRES_IN', '15m'),
    });
  }

  private async _createRefreshToken(userId: string): Promise<string> {
    const payload = { sub: userId }; // Keep refresh token payload minimal
    return this.jwtService.signAsync(payload, {
      secret: this.configService.get<string>('JWT_REFRESH_SECRET'),
      expiresIn: this.configService.get<string>('JWT_REFRESH_EXPIRES_IN', '7d'),
    });
  }

  // Placeholder for Auth0 Management API Token - requires Auth0 SDK and setup
  async getAuth0ManagementApiToken(): Promise<{ managementApiToken: string }> {
    // This would involve calling Auth0 to get a Management API token
    // using client credentials flow (M2M application in Auth0)
    // Securely store and use your Auth0 domain, client ID, and client secret (from ConfigService)
    // Example using `auth0` package:
    /*
    const { ManagementClient } = require('auth0');
    const management = new ManagementClient({
      domain: this.configService.get('AUTH0_DOMAIN'),
      clientId: this.configService.get('AUTH0_M2M_CLIENT_ID'),
      clientSecret: this.configService.get('AUTH0_M2M_CLIENT_SECRET'),
      scope: 'read:users update:users' // Or whatever scopes you need
    });
    const token = await management.getAccessToken(); // This is a simple way, might need caching
    return { managementApiToken: token };
    */
    console.warn('Auth0 Management API Token retrieval is not implemented.');
    throw new Error('Auth0 Management API Token retrieval not implemented.');
  }

  async generateManagementToken(userId: string, resourceId: string, resourceType: string): Promise<{ token: string; expiresIn: number; resourceId: string; resourceType: string }> {
    // Verify the user exists
    const user = await this.userRepository.findOne({ where: { id: userId } });
    if (!user) {
      throw new NotFoundException('User not found');
    }

    // Verify the resource exists based on resourceType
    // This would need to be expanded based on the actual resource types supported
    // For example, checking if a document exists in the document repository, etc.

    // Generate a management token with limited scope and short expiration
    const expiresIn = 1800; // 30 minutes in seconds
    const payload = {
      sub: userId,
      resourceId: resourceId,
      resourceType: resourceType,
      scope: 'management',
    };

    const token = this.jwtService.sign(payload, {
      expiresIn: expiresIn,
      secret: this.configService.get<string>('JWT_SECRET'),
    });

    return {
      token,
      expiresIn,
      resourceId,
      resourceType,
    };
  }
}
